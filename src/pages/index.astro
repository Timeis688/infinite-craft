---
import Trash from '../components/trash.astro'
import DarkMode from '../components/dark-mode.astro'
import Magic from '../components/magic.astro'
import Time from '../components/time.astro'
import Layout from '../layouts/Layout.astro'
import { bag, canBeCrafted, recipes } from '../lib/bag'
import Clear from '../components/clear.astro'
import { trim } from '../lib/utils'

const starter = [
  'Water',
  'Coal',
  'Rock',
  'Iron Ore',
  'Aluminum Ore',
  'Sand',
  'Clay',
  'Raw Emerald',
  'Raw Ruby',
  'Gold Ore',
  'Stick'
].map(name => {
  const item = canBeCrafted.find(item => item.name === name)
  const slug = trim(item.reaction, ':')
  return {
    ...item,
    quantity: 1,
    discovered: false,
    time: Date.now(),
    image: `https://raw.githubusercontent.com/hackclub/bag-manifest/production/images/${slug}.png`
  }
})

// https://raw.githubusercontent.com/hackclub/bag-manifest/production/images/-acorn.png
const table = canBeCrafted.map(item => {
  const slug = trim(item.reaction, ':')
  return {
    ...item,
    quantity: 1,
    discovered: false,
    time: Date.now(),
    image: `https://raw.githubusercontent.com/hackclub/bag-manifest/production/images/${slug}.png`
  }
})

let current = starter
---

<Layout>
  <div id="container">
    <div id="left">
      <div id="logo">
        <h1>Infinite Craft</h1>
        <a href="https://bag.hackclub.com" target="_blank">
          <img src="/assets/logo.png" />
        </a>
      </div>
      <div id="crafting"></div>
      <div id="toolbar">
        <div>
          <button id="reset">Reset</button>
        </div>
        <div class="icons">
          <button id="trash">
            <Trash />
          </button>
          <button id="theme">
            <DarkMode />
          </button>
          <button id="clear">
            <Clear />
          </button>
          <button id="sound">
            <svg
              width="100%"
              height="100%"
              viewBox="0 0 44 45"
              version="1.1"
              xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink"
              xml:space="preserve"
              xmlns:serif="http://www.serif.com/"
              style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
              <g transform="matrix(1,0,0,1,0.20625,-2.825)">
                <path
                  d="M24.156,3C23.852,3 23.551,3.063 23.25,3.156C22.645,3.348 22.066,3.707 21.563,4.219L9.813,15.969L3,15.969C1.332,15.969 -0.031,17.332 -0.031,19L-0.031,31C-0.031,32.668 1.332,34.031 3,34.031L9.813,34.031L21.531,45.688C22.648,46.809 24.082,47.301 25.25,46.75C26.426,46.195 27,44.859 27,43.313L27,6.313C27,4.813 26.234,3.566 25.063,3.156C24.77,3.055 24.461,3 24.156,3ZM24.188,5C24.289,5 24.367,5.008 24.438,5.031C24.723,5.129 25,5.383 25,6.313L25,43.313C25,44.379 24.648,44.855 24.406,44.969C24.164,45.082 23.676,45.094 22.906,44.313L10.313,31.719C10.293,31.707 10.27,31.695 10.25,31.688C10.324,31.754 10,31.121 10,30.75L10,19.25C10,18.879 10.336,18.238 10.25,18.313C10.273,18.293 10.293,18.273 10.313,18.25L22.969,5.625C23.438,5.152 23.879,5.004 24.188,5ZM3,18.031L8.188,18.031C8.059,18.414 8,18.832 8,19.25L8,30.75C8,31.168 8.063,31.582 8.188,31.969L3,31.969C2.461,31.969 2.031,31.539 2.031,31L2.031,19C2.031,18.461 2.461,18.031 3,18.031ZM31.906,18.969C31.863,18.977 31.82,18.988 31.781,19C31.406,19.066 31.105,19.34 31,19.703C30.895,20.07 31.004,20.461 31.281,20.719L35.563,25L31.281,29.281C30.883,29.68 30.883,30.32 31.281,30.719C31.68,31.117 32.32,31.117 32.719,30.719L37,26.438L41.281,30.719C41.68,31.117 42.32,31.117 42.719,30.719C43.117,30.32 43.117,29.68 42.719,29.281L38.438,25L42.719,20.719C43.043,20.418 43.129,19.941 42.934,19.547C42.742,19.148 42.309,18.93 41.875,19C41.652,19.023 41.441,19.125 41.281,19.281L37,23.563L32.719,19.281C32.512,19.059 32.211,18.945 31.906,18.969Z"
                  style="fill-rule:nonzero;stroke-width:0.35px;"></path>
              </g>
            </svg>
          </button>
        </div>
      </div>
    </div>
    <div id="right">
      <div id="menu">
        {
          current.map(item => (
            <div class="item display" data-add data-value={item.name}>
              <img src={item.image} />
              <span>{item.name}</span>
            </div>
          ))
        }
      </div>
      <div id="extra">
        <div class="options">
          <button id="discoveries">
            <Magic />
            <span>Discoveries</span>
          </button>
          <button id="sort">
            <Time />
            <span>Sort by time</span>
          </button>
        </div>
        <div class="search">
          <input
            id="search"
            type="text"
            placeholder={`Search (${current.length}) items`}
          />
        </div>
      </div>
    </div>
  </div>
  <div id="nodes"></div>
  <script is:inline define:vars={{ items: current, recipes }}>
    const initialNodes = 128
    const nodeSize = 5
    const pinwheelSize = 90
    const pinwheelSpin = 4
    const random = (min, max) =>
      Math.floor(Math.random() * (max - min + 1) + min)
    const distance = (a, b) =>
      Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))

    const getNode = (n, v) => {
      if (typeof n === 'string' || n instanceof String)
        n = document.createElementNS('http://www.w3.org/2000/svg', n)
      for (let p in v)
        n.setAttributeNS(
          null,
          p.replace(/[A-Z]/g, function (m, p, o, s) {
            return '-' + m.toLowerCase()
          }),
          v[p]
        )
      return n
    }

    class Node {
      constructor(maxX) {
        this.opacity = random(0.5, 1).toString()
        this.moving = true

        this.node = document.createElement('div')
        this.node.classList.add('node')
        this.node.style.opacity = this.opacity.toString()

        this.initialX = random(0, maxX)
        this.initialY = random(0, window.innerHeight)
        this.x = this.initialX
        this.y = this.initialY
        this.maxX = maxX
        this.dirX = random(-1, 1)
        this.dirY = random(-1, 1)
        this.goto(this.x, this.y)
      }

      goto(x, y) {
        this.node.style.top = `${y}px`
        this.node.style.left = `${x}px`
        if (this.line) {
          // Adjust line too
          this.line.setAttributeNS(null, 'x2', this.x + nodeSize / 2)
          this.line.setAttributeNS(null, 'y2', this.y + nodeSize / 2)
        }
      }

      connect(x, y, endX, endY) {
        // Connect a line
        const svg = getNode('svg')
        this.line = getNode('line', {
          x1: (x + endX) / 2,
          y1: (y + endY) / 2,
          x2: this.x + nodeSize / 2,
          y2: this.y + nodeSize / 2,
          opacity: this.opacity
        })
        this.dirX /= random(1.5, 2)
        this.dirY /= random(1.5, 2)
        svg.appendChild(this.line)
        document.body.appendChild(svg)
        return this.line
      }

      disconnect() {
        // Destroy line
        this.line.parentNode.removeChild(this.line)
        this.line = undefined
      }

      render() {
        if (this.moving) {
          this.x += this.dirX
          this.y += this.dirY
          this.goto(this.x, this.y)
          if (
            this.x < 0 ||
            this.x > this.maxX ||
            this.y < 0 ||
            this.y > window.innerHeight
          ) {
            this.dirX = -this.dirX
            this.dirY = -this.dirY
          }
          if (this.line) {
            // TODO: Better reverse direction. Perhaps individually rather then together
            if (Math.abs(this.x - this.initialX) > 50) this.dirX = -this.dirX
            if (Math.abs(this.y - this.initialY) > 50) this.dirY = -this.dirY
          }
        }
      }
    }

    class Instance {
      constructor(item, index, maxX) {
        this.nodes = []
        this.index = index
        this.items = [Object.assign({}, item)]

        this.instance = document.createElement('div')
        this.instance.classList.add('item')
        this.instance.classList.add('using')
        this.generate()
        document.body.appendChild(this.instance)

        this.x = Math.random() * (maxX - this.instance.offsetWidth * 2)
        this.y =
          Math.random() * (window.innerHeight - this.instance.offsetHeight * 2)
        this.endX = this.x + this.instance.offsetWidth
        this.endY = this.y + this.instance.offsetHeight
        this.goto(this.x, this.y)

        // Make instance draggable
        this.instance.onmousedown = event => this.dragMouseDown(event, this)
      }

      dragMouseDown(event, self) {
        event.preventDefault()
        self.startX = event.clientX
        self.startY = event.clientY
        self.instance.classList.add('top')
        document.onmouseup = () => self.closeDragElement(self)
        document.onmousemove = event => self.elementDrag(event, self)
      }

      elementDrag(event, self) {
        event.preventDefault()
        self.x = self.instance.offsetLeft - (self.startX - event.clientX)
        self.y = self.instance.offsetTop - (self.startY - event.clientY)
        self.endX = self.x + self.instance.offsetWidth
        self.endY = self.y + self.instance.offsetHeight
        self.startX = event.clientX
        self.startY = event.clientY
        self.goto(self.x, self.y)
      }

      closeDragElement(self) {
        document.onmouseup = null
        document.onmousemove = null
        self.instance.classList.remove('top')
        state.interact(self.index)
      }

      goto(x, y) {
        this.instance.style.top = `${y}px`
        this.instance.style.left = `${x}px`
        if (this.index !== undefined) state.editInstance(this.index)
      }

      collide(other) {
        // Check if colliding with other instance
        if (
          this.x < other.endX &&
          this.endX > other.x &&
          this.y < other.endY &&
          this.endY > other.y
        )
          return true
        return false
      }

      showInteraction() {
        this.instance.classList.add('interact')
      }

      removeInteraction() {
        if (this.instance.classList.contains('interact'))
          this.instance.classList.remove('interact')
      }

      animate() {
        // Play an animation in the background!
        const image = new Image()
        image.onload = () => {
          image.classList.add('pinwheel')
          image.style.left = `${(this.x + this.endX) / 2 - pinwheelSize}px`
          image.style.top = `${(this.y + this.endY) / 2 - pinwheelSize}px`
          document.body.appendChild(image)
          state.play('reward')
          image.classList.add('spin')
          setTimeout(() => {
            document.body.removeChild(image)
          }, pinwheelSpin * 100)
        }
        image.src = '/assets/pinwheel.png'
      }

      interact(instance) {
        for (let item of instance.items) {
          const search = this.items.findIndex(({ name }) => name === item.name)
          if (search > -1)
            // Combine with item that already exists
            this.items[search].quantity += item.quantity
          // Add
          else this.items.push(item)
        }
        instance.destroy()
        this.generate()
      }

      generate() {
        let text = []
        for (let item of this.items) {
          text.push(`
        <img src="${item.image}"/>
        <span>x${item.quantity} ${item.name}</span>
      `)
        }
        this.instance.innerHTML = text.join('<span>,</span>')

        // Adjust endX and endY
        this.endX = this.x + this.instance.offsetWidth
        this.endY = this.y + this.instance.offsetHeight
      }

      destroy() {
        // Destroy
        for (let node of this.nodes) node.disconnect()
        document.body.removeChild(this.instance)
      }
    }

    class State {
      constructor(items) {
        this.nodes = []
        this.instances = []
        this.inventory = items
        this.audio = {
          instance: new Audio('/audio/instance.mp3'),
          reward: new Audio('/audio/reward.mp3'),
          delete: new Audio('/audio/delete.mp3'),
          error: new Audio('/audio/error.mp3')
        }
        this.on = true
        this.theme = localStorage.getItem('theme')
      }

      addInstance(name, maxX) {
        const instance = new Instance(
          this.inventory.find(item => item.name === name),
          undefined,
          maxX
        )
        this.instances.push(instance)
        instance.index = this.instances.length - 1
        // Find nodes nearby and connect!
        let nodes = this.nodes
          .filter(node => {
            if (node.line) return false
            if (distance(node, instance) < 100) return false
            return true
          })
          .sort((a, b) => {
            if (distance(a, instance) > distance(b, instance)) return 1
            return -1
          })
          .slice(0, random(3, 8))
        for (let node of nodes) {
          instance.nodes.push(node)
          node.connect(instance.x, instance.y, instance.endX, instance.endY)
        }
      }

      editInstance(index) {
        const instance = this.instances[index]

        // Check if overlapping with any other instances
        for (let [i, other] of this.instances.entries()) {
          if (i === index) continue
          if (instance.collide(other)) other.showInteraction()
          else other.removeInteraction()
        }

        // Find nodes nearby and connect!
        for (let node of instance.nodes) {
          document.body.removeChild(node.line.parentNode)
          node.line = undefined
        }
        instance.nodes = []

        let nodes = this.nodes
          .filter(node => {
            if (node.line) return false
            return true
          })
          .sort((a, b) => {
            if (distance(a, instance) > distance(b, instance)) return 1
            return -1
          })
          .slice(0, random(3, 8))
        for (let node of nodes) {
          instance.nodes.push(node)
          node.connect(instance.x, instance.y, instance.endX, instance.endY)
        }
      }

      interact(index) {
        // Combine instances if they're overlapping!
        const instance = this.instances[index]
        const combine = []

        for (let [i, other] of this.instances.entries()) {
          if (i === index) continue
          if (instance.collide(other)) {
            combine.push(i)
            other.removeInteraction()
          }
        }

        if (!combine.length) return

        // Now combine them instances
        const instances = [
          ...this.instances[index].items,
          ...combine.map(i => this.instances[i].items)
        ].flat()
        let canMake = []
        let complete
        for (let recipe of recipes) {
          // Check to make sure all instances are in recipe
          const ingredients = [...recipe.inputs, ...recipe.tools]
          if (partial(ingredients, instances)) {
            if (exact(ingredients, instances))
              // Exact recipe, so craft, and check if it's a new discovery!
              complete = recipe.outputs
            canMake.push(recipe)
          }
        }

        if (!canMake.length) return this.play('error')

        // If recipes exist, combine them
        let updated = this.instances
        for (let instance of combine) {
          this.instances[index].interact(this.instances[instance])
          if (complete) {
            if (complete.length === 1) {
              this.instances[index].items = complete
              this.instances[index].generate()

              // Check if it's a new discovery!
              if (
                !this.inventory.find(item => item.name === complete[0].name)
              ) {
                this.instances[index].animate()
                this.inventory.push({
                  ...complete[0],
                  discovered: true,
                  time: Date.now()
                })
                generateInventory(this.inventory)
                this.save()
              }
            }
          }
          updated.splice(instance, 1)
        }
        for (let i = 0; i < updated.length; i++) updated[i].index = i
        this.instances = updated
      }

      render() {
        for (let node of this.nodes) node.render()
      }

      play(kind) {
        if (this.on) return this.audio[kind].play()
      }

      save() {
        // Save to localStorage
        localStorage.setItem('inventory', JSON.stringify(this.inventory))
      }

      clear() {
        // Clear the canvas!
        for (let instance of this.instances) instance.destroy()
        this.instances = []
      }
    }

    let state = new State(
      localStorage.getItem('inventory')
        ? JSON.parse(localStorage.getItem('inventory'))
        : items
    )
    let maxX

    const partial = (ingredients, instances) => {
      // Check if ingredients contains instances
      let recipe = JSON.parse(JSON.stringify(ingredients))
      for (let instance of instances) {
        // Check if in ingredients
        const index = recipe.findIndex(
          ingredient => ingredient.recipeItemId === instance.name
        )
        if (index < 0) return false

        // Check if quantity matches
        if (recipe[index].quantity - instance.quantity < 0) return false
        recipe[index].quantity -= instance.quantity
      }
      return true
    }

    const exact = (ingredients, instances) => {
      // Check if instances = ingredients
      let recipe = JSON.parse(JSON.stringify(ingredients))
      for (let instance of instances) {
        // Check if in ingredients
        const index = recipe.findIndex(
          ingredient => ingredient.recipeItemId === instance.name
        )
        recipe[index].quantity -= instance.quantity
        if (!recipe[index].quantity) recipe.splice(index, 1)
      }
      if (recipe.length) return false
      return true
    }

    const generateInventory = items => {
      document.querySelectorAll('[data-add]').forEach(node => {
        node.parentNode.removeChild(node)
      })

      for (let item of items) {
        const add = document.createElement('div')
        add.classList.add('item')
        add.classList.add('display')
        add.setAttribute('data-add', null)
        add.setAttribute('data-value', item.name)
        add.innerHTML = `
      <img src="${item.image}"/>
      <span>${item.name}</span>
    `
        add.addEventListener('click', event => {
          state.play('instance')
          const value =
            event.target.dataset.value ||
            event.target.parentElement.dataset.value
          state.addInstance(value, maxX)
        })
        document.getElementById('menu').appendChild(add)
      }
    }

    const setTheme = theme => {
      for (let [key, value] of Object.entries(theme))
        document.documentElement.style.setProperty(key, value)
    }

    window.onload = () => {
      maxX = window.innerWidth - document.getElementById('menu').offsetWidth

      // Let's load some nodes!
      for (let i = 0; i < initialNodes; i++) {
        const node = new Node(maxX)
        state.nodes.push(node)
        document.body.appendChild(node.node)
      }

      generateInventory(state.inventory)

      setInterval(() => state.render(), 50)

      document.getElementById('reset').addEventListener('click', () => {
        const sure = confirm('Are you sure? This will delete all your progess!')
        if (sure) {
          localStorage.clear()
          state.clear()
          state = new State(items)
        }
      })

      document.getElementById('theme').addEventListener('click', () => {
        const theme = document.body.getAttribute('theme')
        if (theme === 'dark') {
          document.body.setAttribute('theme', 'light')
          setTheme({
            '--background': 'white',
            '--foreground': 'black',
            '--button-color': '#040404',
            '--gray': '#c8c8c8',
            '--instance-background': 'white',
            '--instance-bg-hover': 'linear-gradient(0deg, #d6fcff, #fff 90%)',
            '--discoveries-background': '#fff9ea',
            '--node-background': '#c8c8c8',
            '--node-stroke': '#e8e8e8'
          })
        } else {
          document.body.setAttribute('theme', 'dark')
          setTheme({
            '--background': '#000',
            '--foreground': 'white',
            '--button-color': '#909090',
            '--gray': '#d1d1d1',
            '--instance-background': '#000',
            '--instance-bg-hover': 'linear-gradient(180deg,#3d4249,#000 80%)',
            '--discoveries-background': '#000',
            '--node-background': '#808080',
            '--node-stroke': '#606060'
          })
        }
      })

      document
        .getElementById('clear')
        .addEventListener('click', () => state.clear())

      document.getElementById('sound').addEventListener('click', () => {
        if (state.on) {
          state.on = false
          // TODO: Change symbol
          document.getElementById('sound').innerHTML = `
          <svg
            width="100%"
            height="100%"
            viewBox="0 0 44 45"
            version="1.1"
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            xml:space="preserve"
            xmlns:serif="http://www.serif.com/"
            style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
            <g transform="matrix(1,0,0,1,0.18125,-2.85)">
              <path
                d="M24.156,3C23.852,3 23.551,3.063 23.25,3.156C22.645,3.348 22.066,3.707 21.563,4.219L9.813,15.969L3,15.969C1.332,15.969 -0.031,17.332 -0.031,19L-0.031,31C-0.031,32.668 1.332,34.031 3,34.031L9.813,34.031L21.531,45.688C22.648,46.809 24.082,47.301 25.25,46.75C26.426,46.195 27,44.859 27,43.313L27,6.313C27,4.813 26.234,3.566 25.063,3.156C24.77,3.055 24.461,3 24.156,3ZM24.188,5C24.289,5 24.367,5.008 24.438,5.031C24.723,5.129 25,5.383 25,6.313L25,43.313C25,44.379 24.648,44.855 24.406,44.969C24.164,45.082 23.676,45.094 22.906,44.313L10.313,31.719C10.293,31.707 10.27,31.695 10.25,31.688C10.324,31.754 10,31.121 10,30.75L10,19.25C10,18.879 10.336,18.238 10.25,18.313C10.273,18.293 10.293,18.273 10.313,18.25L22.969,5.625C23.438,5.152 23.879,5.004 24.188,5ZM34.719,12.125C34.273,12.18 33.918,12.527 33.855,12.973C33.789,13.414 34.027,13.848 34.438,14.031C38.34,16.137 41,20.246 41,25C41,29.738 38.352,33.859 34.469,35.969C33.984,36.234 33.809,36.844 34.078,37.328C34.344,37.813 34.953,37.988 35.438,37.719C39.945,35.27 43,30.484 43,25C43,19.5 39.938,14.695 35.406,12.25C35.227,12.148 35.02,12.105 34.813,12.125L34.719,12.125ZM3,18.031L8.188,18.031C8.059,18.414 8,18.832 8,19.25L8,30.75C8,31.168 8.063,31.582 8.188,31.969L3,31.969C2.461,31.969 2.031,31.539 2.031,31L2.031,19C2.031,18.461 2.461,18.031 3,18.031ZM30.531,18.406C30.047,18.465 29.68,18.863 29.656,19.352C29.633,19.836 29.961,20.27 30.438,20.375C32.484,20.91 34,22.777 34,25C34,27.223 32.484,29.09 30.438,29.625C29.902,29.762 29.582,30.309 29.719,30.844C29.855,31.379 30.402,31.699 30.938,31.563C33.848,30.801 36,28.137 36,25C36,21.863 33.848,19.199 30.938,18.438C30.805,18.398 30.668,18.391 30.531,18.406Z"
                style="fill-rule:nonzero;stroke:black;stroke-width:0.3px;"></path>
            </g>
          </svg>
          `
        } else {
          state.on = true
          document.getElementById('sound').innerHTML = `
          <svg
            width="100%"
            height="100%"
            viewBox="0 0 44 45"
            version="1.1"
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            xml:space="preserve"
            xmlns:serif="http://www.serif.com/"
            style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
            <g transform="matrix(1,0,0,1,0.20625,-2.825)">
              <path
                d="M24.156,3C23.852,3 23.551,3.063 23.25,3.156C22.645,3.348 22.066,3.707 21.563,4.219L9.813,15.969L3,15.969C1.332,15.969 -0.031,17.332 -0.031,19L-0.031,31C-0.031,32.668 1.332,34.031 3,34.031L9.813,34.031L21.531,45.688C22.648,46.809 24.082,47.301 25.25,46.75C26.426,46.195 27,44.859 27,43.313L27,6.313C27,4.813 26.234,3.566 25.063,3.156C24.77,3.055 24.461,3 24.156,3ZM24.188,5C24.289,5 24.367,5.008 24.438,5.031C24.723,5.129 25,5.383 25,6.313L25,43.313C25,44.379 24.648,44.855 24.406,44.969C24.164,45.082 23.676,45.094 22.906,44.313L10.313,31.719C10.293,31.707 10.27,31.695 10.25,31.688C10.324,31.754 10,31.121 10,30.75L10,19.25C10,18.879 10.336,18.238 10.25,18.313C10.273,18.293 10.293,18.273 10.313,18.25L22.969,5.625C23.438,5.152 23.879,5.004 24.188,5ZM3,18.031L8.188,18.031C8.059,18.414 8,18.832 8,19.25L8,30.75C8,31.168 8.063,31.582 8.188,31.969L3,31.969C2.461,31.969 2.031,31.539 2.031,31L2.031,19C2.031,18.461 2.461,18.031 3,18.031ZM31.906,18.969C31.863,18.977 31.82,18.988 31.781,19C31.406,19.066 31.105,19.34 31,19.703C30.895,20.07 31.004,20.461 31.281,20.719L35.563,25L31.281,29.281C30.883,29.68 30.883,30.32 31.281,30.719C31.68,31.117 32.32,31.117 32.719,30.719L37,26.438L41.281,30.719C41.68,31.117 42.32,31.117 42.719,30.719C43.117,30.32 43.117,29.68 42.719,29.281L38.438,25L42.719,20.719C43.043,20.418 43.129,19.941 42.934,19.547C42.742,19.148 42.309,18.93 41.875,19C41.652,19.023 41.441,19.125 41.281,19.281L37,23.563L32.719,19.281C32.512,19.059 32.211,18.945 31.906,18.969Z"
                style="fill-rule:nonzero;stroke-width:0.35px;"></path>
            </g>
          </svg>
          `
        }
      })

      document
        .getElementById('discoveries')
        .addEventListener('click', event => event.target.classList.add('focus'))

      document.getElementById('search').addEventListener('input', event => {
        if (!event.target.value.length)
          return generateInventory(state.inventory)
        const results = state.inventory.filter(item =>
          item.name.toLowerCase().startsWith(event.target.value.toLowerCase())
        )
        generateInventory(results)
      })
    }
  </script>
</Layout>
